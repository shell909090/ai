# 代码规范

* 使用logging处理日志。
* 每种workflow一个py文件，JSON格式的workflow以字符串形式保存其中。提供一个或多个函数，供外部调用。
* 测试和构建过程使用Makefile控制
* 环境使用uv管理

# 文件和用途

* libs.py: 公共库。
* wf.py: workflow的入口脚本。从命令行读取多种参数，调用对应workflow执行。
* outpaint.py: 扩图workflow。
* upscale.py: 超分workflow。这里只用模型超分，不重绘，也不调整分辨率，只负责直接扩大4倍。
* usdu.py: 超分workflow。重绘，调整分辨率。
* zit.py: z-image-turbo图片生成workflow。
* gen-images.py: 批量生成图片。

## gen-images的核心逻辑

合成逻辑：
每次合成有4个关键参数，主题，变奏，随机数，分辨率。合成逻辑如下：
1. 命令行参数theme，读取主题。
2. 命令行参数variations，读取变奏。
3. 每行一个变奏，和主题混合，生成提示词。
4. 每个提示词，给一个序列ID，作为文件编号。对于同一个序列ID，提示词一样。
5. 每个提示词，可以生成多个批次。每个批次，给一个批次ID。同时生成一个随机数。每一个序列ID的每一个批次ID，随机数一样。
6. 如果指定了分辨率规范文件，读取里面所有分辨率。
7. 目标文件名为{文件编号}_{批次编号}_{device_id}.png，如果没有指定分辨率规范文件，{文件编号}_{批次编号}.png。

分辨率细节：
由于所有模型都有分辨率极限，因此在总像素（width*height）超过特定值（估计在1024*1024到2048*2048之间）之后，需要结合使用upscale过程。否则容易出现图片扭曲，断肢等现象。同时，又由于ComfyUI的特性，频繁切换模型性能极低。因此upscale需要在zit模型全部跑完之后。又，zit过程跑的时候总有中断的情况。所以万一中断了，那么跑出来的中间文件，就不必再跑了。
具体如下：
1. 拿到一张图，判断总像素是否超过了1.5*1024*1024。
2. 如果没超过，直接调用zit.zit生成。
3. 如果超过了，width和height各自乘以2/3。
4. 然后再看有没有超过1024*1024。如果还超过了，回到步骤3。
5. 看一眼临时文件是否存在。存在就不用跑了。
6. 不存在的话。使用width和height，调用zit.zit，生成临时文件。
7. 全部图片/临时图片生成完之后，判断是否有临时文件需要放大。
8. 如果有，调用upscale，生成目标图片。
9. 使用PIL，读取目标图片分辨率。如果不严格等于要求的分辨率，直接用PIL进行小幅缩放。
10. 清理所有临时文件。
